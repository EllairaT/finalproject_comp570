/* autogenerated by Processing revision 1282 on 2022-06-02 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import controlP5.*;
import uibooster.*;
import uibooster.components.*;
import uibooster.model.*;
import uibooster.model.formelements.*;
import uibooster.model.options.*;
import uibooster.utils.*;
import java.util.Stack;
import java.util.Map;
import java.util.Map;
import java.io.File;
import java.util.Iterator;
import java.util.Set;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class FinalProject extends PApplet {











static SpriteManager sm;
static int currentX;
static int currentY;
UiBooster ui;
Game game;
PFont font;
ControlP5 cp5;


/**
Setting up variables and libraries to be used globally.
*/
 public void setup() {
    /* size commented out by preprocessor */;
    // size(500,500,P2D);
    surface.setResizable(true);
    surface.setTitle("RESISTANCE");
    font = loadFont("Fonts/Onyx-64.vlw");
    sm = new SpriteManager();
    sm.start();
    cp5 = new ControlP5(this);
    game = new Game();
    currentX = 0;
    currentY = 0;
    textFont(font);
    noStroke();  
    
    
}

 public void draw() {
    background(150);
    fill(0);
    game.drawWorld();
}

// multiple images will be present 
 public void preload() {
    
}

/**
* Game class contains the game state and general methods and helper functions. 
*
* @author Ellaira Torio | 18021275
*/

class Game {
    
    
    World world;
    
    public Game() {
        
        world = new World();
        
    }
    
    
    
    public void displayMainMenu() {
        // mainMenu.display();       
        
    }
    
    public void drawWorld() {
        world.showWorld();
    }
    
    
}
/**
* 
*
* @author Ellaira Torio | 18021275
*/
abstract class GameEntity{
    PVector position;
    boolean isVisible;
    boolean isAlive;
    int health;
    
    public void spawnAt(float x, float y) {}
    public void despawn() {}
    
    public void toggleVisible() {
        isVisible = !isVisible;
    }
    
    public void takeDamage(float damage) {
        health -= damage;
    }
    
    public void handleCollision(GameEntity g) {
    }
}
/**
* This GSM uses a stack for game states
*
* @author Ellaira Torio | 18021275
*/


enum GameState{
    ENTERED, RUNNING, PAUSED, QUITTING
}

class GameStateManager {
    Stack<String> s = new Stack<String>();
    
    public GameStateManager() {
        
    }
    
}

/**
* Sketch for main menu screen.
*
* https://www.sojamo.de/libraries/controlP5/examples/use/ControlP5callback/ControlP5callback.pde
* @author Ellaira Torio | 18021275
*/



class MainMenu {
    PImage bgImg; 
    PImage logo; 
    String[] options = new String[]{"play", "tutorial", "exit"};
    
    public MainMenu() {
        // try {
        //     bgImg = requestImage("menu_bg.png");
        //     logo = requestImage("Logo_pixel.png");
        
        
// } catch(Exception e) {
        //     ui.showException("Something went wrong", "Error", e);
// }
    }
    
    public void display() {
        renderTextButtons();
        renderBackground();
        renderLogo();
    }
    
    private void renderBackground() {
        if (!(bgImg.width <= 0)) {
            background(bgImg);
        }
    }
    
    private void renderLogo() {
        if (!(logo.width <= 0)) {
            image(logo,0,0);
        }
    }
    
    private void renderTextButtons() {
        int spacing = 120;
        fill(255);
        textAlign(CENTER);
        // text("PLAY", logo.width / 2, logo.height + spacing);
        // text("TUTORIAL", logo.width / 2, logo.height + (spacing * 2));
        // text("EXIT", logo.width / 2, logo.height + (spacing * 3));
        
        
        for (int i = 0; i < options.length; i++) {
            cp5.addTextlabel(options[i] + "_btn")
               .setText(options[i])
               .setPosition(logo.width / 2, logo.height + (spacing * i))
               .setColorValue(255)
               .setFont(font);
        }
    }
    // public void play(float value) {
    //     println(value);
// }
    
    public void clickHandler() {
        println("lmao nice");
    }
    // public void exit(float value) {
    //  println(value);
// }
}
class Monster extends GameEntity {
    String name;
    float speed, damage;
    boolean isAlive;
    PImage cardImage;
    AnimatedSprite sprite;
    
    
    public Monster(String n) {
        name = n;
    }
    
    
    public void walk() {}
    public void attack() {}
    public void playSpawnSound() {}
}


class Demon extends Monster {
    public Demon() {
        super("Demon");
    }
}

class Golem extends Monster {
    public Golem() {
        super("Golem");
    }
}

class Sprite {
    SpriteType type;
    String name;
    boolean isAnimated;
    PImage spriteImg;
    JSONObject spriteData;
    
    public Sprite(SpriteType t, String n, boolean b, PImage img, JSONObject d) {
        type = t;
        name = n;
        isAnimated = b;
        spriteImg = img;
        spriteData = d;
    }
    
    public PImage getImage() {
        return spriteImg;
    }
    public void showSprite() {}
    
}

class AnimatedSprite extends Sprite{
    ArrayList<PImage> idleAnim;
    ArrayList<PImage> walkingAnim;
    ArrayList<PImage> attackingAnim;
    int length, index;
    float speed;
    
    public AnimatedSprite(SpriteType t, String n, boolean b, PImage sh, JSONObject d) {
        super(t,n,b,sh,d);
    }
    
    private void findFrames(ArrayList<PImage> animation) {}
    public void animateIdle() {}
    public void animateWalk() {}
    public void animateAttack() {}
}
/**
* 
* @author Ellaira Torio | 18021275
*/






enum SpriteType{
    TOWER,
    MONSTER,
    CARD,
}

class Meta{    
    PImage img;
    JSONObject data;
    JSONArray objects;
    SpriteType type;
    
    public Meta(String i, String o, JSONArray arr, String t) {
        try{
            img = loadImage(i); // this is where the images and such actually get loaded in 
            data = loadJSONObject(o);
            objects = arr;
            type = SpriteType.valueOf(t);
        }
        catch(Exception e) {
            println("Error loading files: " +  e);
        }
    }   
    
    // for debugging purposes
    public String toString() {
        return img.toString() + "; " + type.toString() + "; " + data.hashCode() + "; " + objects.toString();
    }
}

class SpriteManager {
    JSONObject data;
    HashMap<String,Sprite> sprites;
    HashMap<String, Meta> spriteSheetData;
    File folder = new File(dataPath("Sprites"));
    
    public SpriteManager() {
        sprites = new HashMap<String,Sprite>();
        spriteSheetData = new HashMap<String,Meta>();
        data = loadJSONObject("game_info.json");
    }
    
    // it is far better to load each spritesheet once and then get the actual image data
    // based on its coordinates, which is defined in its corresponding json object
    // instead of loading the image file every time a sprite is needed
    public void loadData() {
        Set<String> arr = data.keys();
        try{
            for (String o : arr) {
                String key = "";
                if (data.get(o) instanceof JSONObject) {
                    key = o;
                    JSONObject m = data.getJSONObject(o).getJSONObject("meta");
                    JSONArray a = data.getJSONObject(o).getJSONArray("objects");
                    Meta meta = new Meta(m.getString("imgSource"), m.getString("dataSource"), a, key);
                    spriteSheetData.put(key, meta);
                }
                else{
                    JSONArray array = data.getJSONArray(o);
                    key = "MONSTER";
                    for (int i = 0; i < array.size(); i++) {
                        JSONObject m = array.getJSONObject(i);
                        String name = key + "_" + m.getString("name");
                        Meta meta = new Meta(m.getString("imgSource"), m.getString("dataSource"), null, key);
                        spriteSheetData.put(name, meta); 
                    }
                }
            }
        }
        catch(Exception e) {
            println("Error while loading: " + e.getMessage());
        }
    }
    
    public void createSprites() {
        for (Map.Entry < String, Meta > entry : spriteSheetData.entrySet()) {
            String key = entry.getKey();
            Meta value = entry.getValue();
            
            println("Creating " + key + " sprites");
            // those with the objects array have multiple sprites in one image file 
            // so these would be tower, card
            if (value.objects != null) {            
                for (int i = 0; i < value.objects.size(); i++) {
                    JSONObject obj = value.objects.getJSONObject(i);
                    JSONObject spriteData = getSpriteData(value.data, obj.getString("filename"));
                    String name = obj.getString("name");
                    boolean isAnimated = obj.getBoolean("isAnimated");
                    
                    if (spriteData != null) {
                        JSONObject position = spriteData.getJSONObject("frame");
                        int x = position.getInt("x");
                        int y = position.getInt("y");
                        int w = position.getInt("w");
                        int h = position.getInt("h");
                        PImage spriteImg = getSpriteByPosition(value.img,x,y,w,h);
                        Sprite sprite = new Sprite(value.type, name, isAnimated, spriteImg, spriteData);
                        sprites.put(name, sprite);
                    }
                }
            }
            else{
                // createAnimatedSprite();
            }
        }
        println("finished");
    }
    
    // private void createAnimatedSprite(){}
    private PImage getSpriteByPosition(PImage img, int x, int y, int w, int h) {
        return img.get(x,y,w,h);
    }
    
    private JSONObject getSpriteData(JSONObject d, String key) {
        JSONArray frames = d.getJSONArray("frames");
        for (int i = 0; i < frames.size(); i++) {
            JSONObject frame = frames.getJSONObject(i);
            if (key.equals(frame.getString("filename"))) {
                return frame;
            }
        }
        return null;
    }
    
    public Sprite getSpriteByName(String name) {
        for (Sprite o : sprites.values()) {
            if (name.equals(o.name)) {
                return o;
            }
        }
        return null;
    }
    
    public void start() {
        println("loading and creating sprites...");
        loadData();
        createSprites();
    }
}

class Tile {
    int xPos, yPos, h, w;
    boolean isClicked;
    GameEntity currentEntity;
    int xOffset, yOffset;
    
    public Tile(int x, int y, int ww, int hh, int xOff, int yOff) {
        rectMode(CENTER);
        xPos = x;
        yPos = y;
        w = ww;
        h = hh;
        xOffset = xOff;
        yOffset = yOff;
    }
    
    public void toggleState() {
        isClicked = !isClicked;
    }
    
    public void display() {
        if (isMouseOver(mouseX - xOffset, mouseY - yOffset)) {
            fill(255,50);
        }
        else{
            noFill();
        }
        stroke(255, 50);
        rect(xPos, yPos, w, h);
    }
    
    public boolean isMouseOver(int x, int y) {
        boolean isOverX = (x >= xPos && x <= xPos + w);
        boolean isOverY = (y >= yPos && y <= yPos + h);
        
        if (isOverX && isOverY) {
            return true;
        } else{
            return false;
        }
    }
}
class Tower extends GameEntity{
    
}
/**

* @author Ellaira Torio | 18021275
*/  

class World {
    int dim = 100; // dimensions of the tiles in the grid.
    int gridHeight, gridWidth;
    PImage bg,mapImg;
    Tile[][] grid;
    int xOffset, yOffset;
    
    public World() {
        try {
            bg = requestImage("Backgrounds/gamebg.png");
            mapImg = requestImage("Backgrounds/map.png");
            initGrid();
        } catch(Exception e) {
            ui.showException("Something went wrong", "Error", e);
        }
    } 
    
    public void showWorld() {
        drawBackground();
        drawGrid();
    }
    
    private void drawBackground() {
        if (!(bg.width <= 0)) { // width 0 or less means image is not loaded yet (or error happens). 
            imageMode(CORNER);
            image(bg,0,0, width, height);
            imageMode(CENTER);
            image(mapImg, width / 2, height / 2, mapImg.width, height);
        }
    }
    
    private void initGrid() {
        gridHeight = floor(mapImg.height / dim);
        gridWidth = floor(mapImg.width / dim);
        grid = new Tile[gridWidth][gridHeight];
    }
    
    public void drawGrid() {
        if (grid.length == 0) {
            initGrid();
        }
        xOffset = (mapImg.width / 2) + dim - 15;
        yOffset = dim;
        translate(xOffset, yOffset);
        for (int i = 0; i < gridWidth; ++i) {
            for (int j = 0; j < gridHeight; ++j) {
                Tile tile =  new Tile(i * dim, j * dim , dim, dim, xOffset, yOffset);
                grid[i][j] = tile;               
                tile.display();
            }
        }   
    }
}


  public void settings() { fullScreen(P2D); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "FinalProject" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
