/* autogenerated by Processing revision 1283 on 2022-05-23 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import controlP5.*;
import uibooster.*;
import uibooster.components.*;
import uibooster.model.*;
import uibooster.model.formelements.*;
import uibooster.model.options.*;
import uibooster.utils.*;
import java.util.Stack;
import java.util.Map;
import java.util.Map;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class FinalProject extends PApplet {











UiBooster ui;
Game game;
PFont font;

ControlP5 cp5;
/**
Setting up variables and libraries to be used globally.
cp5 in particular needs to be defined in setup.
*/
 public void setup() {
    /* size commented out by preprocessor */;
    surface.setTitle("RESISTANCE");
    noStroke();  
    font = loadFont("Onyx-64.vlw");
    textFont(font);
    cp5 = new ControlP5(this);
    game = new Game();
}

 public void draw() {
    game.displayMainMenu();
}

/**
* Game class contains the game state and general methods and helper functions. 
*
* @author Ellaira Torio | 18021275
*/

class Game {
    MainMenu mainMenu;
    
    public Game() {
        mainMenu = new MainMenu();
    }
    
    public void displayMainMenu() {
        mainMenu.display();
    }
    
}
/**
* This GSM uses a stack for game states
*
* @author Ellaira Torio | 18021275
*/


enum GameState{
    ENTERED, RUNNING, PAUSED, QUITTING
}

class GameStateManager {
    Stack<String> s = new Stack<String>();
    
    public GameStateManager() {
        
    }
    
}

/**
* Sketch for main menu screen.
*
* @author Ellaira Torio | 18021275
*/



class MainMenu {
    PImage bgImg; 
    PImage logo; 
    String[] options = new String[]{"play", "tutorial", "exit"};
    
    public MainMenu() {
        try {
            bgImg = requestImage("menu_bg.png");
            logo = requestImage("Logo_pixel.png");
            renderTextButtons();
            
        } catch(Exception e) {
            ui.showException("Something went wrong", "Error", e);
        }
    }
    
    public void display() {
        renderBackground();
        renderLogo();
    }
    
    private void renderBackground() {
        if (bgImg.width <= 0) {
            background(0);
        }
        else{
            for (int i = 0; i < 500; i++) {
                float x = random(width);
                float y = random(height);
                int c = bgImg.get(PApplet.parseInt(x),PApplet.parseInt(y));
                fill(c);
                noStroke();
                rect(x,y, 10,10);
            }
        }  
    }
    
    private void renderLogo() {
        if (!(logo.width <= 0)) {
            image(logo,0,0);
        }
    }
    
    private void renderTextButtons() {
        int spacing = 120;
        fill(255);
        textAlign(CENTER);
        // text("PLAY", logo.width / 2, logo.height + spacing);
        // text("TUTORIAL", logo.width / 2, logo.height + (spacing * 2));
        // text("EXIT", logo.width / 2, logo.height + (spacing * 3));
        
        
        for (int i = 0; i < options.length; i++) {
            cp5.addTextlabel(options[i] + "_btn")
               .setText(options[i])
               .setPosition(logo.width / 2, logo.height + (spacing * i))
               .setColorValue(255)
               .setFont(font);
            
        }
    }
    // public void play(float value) {
    //     println(value);
// }
    
    public void clickHandler() {
        println("lmao nice");
    }
    // public void exit(float value) {
    //  println(value);
// }
}

abstract class Monster  {
    String name;
    float speed, damage;
    boolean isAlive;
    PImage cardImage;
    AnimatedSprite sprite;
    
    
    public Monster() {
        
    }
    
    public void spawn() {
        isAlive = true;
    }
    
    public void despawn() {
        isAlive = false;
    }
    
    public void walk() {}
    public void attack() {}
    public void idle() {}
    public void playSpawnSound() {}
}


class Demon extends Monster {
    public Demon() {
        // play sound file in spawn
        super();
    }
}

class Golem extends Monster {
    public Golem() {
        super();
    }
}

class Sprite {
    SpriteType type;
    String name;
    float x,y,w;
    boolean isAnimated;
    PImage spriteSheet;
    JSONObject spriteData;
    
    public Sprite(SpriteType t, String n, boolean b, PImage sh, JSONObject d) {
        type = t;
        name = n;
        isAnimated = b;
        spriteSheet = sh;
        spriteData = d;
    }
    
    public void showSprite() {}
}

class AnimatedSprite extends Sprite{
    ArrayList<PImage> idleAnim;
    ArrayList<PImage> walkingAnim;
    ArrayList<PImage> attackingAnim;
    int length, index;
    float speed;
    
    public AnimatedSprite(SpriteType t, String n, boolean b, PImage sh, JSONObject d) {
        super(t,n,b,sh,d);
    }
    
    private void findFrames(ArrayList<PImage> animation) {}
    public void animateIdle() {}
    public void animateWalk() {}
    public void animateAttack() {}
}


enum SpriteType{
    STRUCTURE,
    MONSTER,
    TILE
}

class SpriteManager {
    String[] filenames;
    ArrayList<Sprite> sprites;
    String path = "./data/json";
    
    public SpriteManager() {
        
    }
    
    // private String[] loadFiles() {
    //     File folder = new File(path);
    
// }
    
    public void prepareSprites() {
        
    }
    
    public void showAllSprites() {}
    
    
    public void getSprite(String name) {}
    
}

class Tile {
    boolean isOccupied;
    boolean isEdgeTile;
    int xPos, yPos;
    PImage texture;
    
    public Tile(boolean isEdge, int x, int y) {
        isEdgeTile = isEdge;
        // texture =  isEdgeTile ? loadImage("Tiles/tile_tree.png") : loadImage("Tiles/tile_grass.png");
        texture = loadImage("Sprites/tiles.png");
        xPos = x * texture.width;
        yPos = y * texture.height;
    }
    
    public void drawTile() {
        image(texture, xPos, yPos);
    }
}

/**
* 
* Isometric world generation
* There are two important things to note:
* converting local isometric grid coords to global screen-space coordinates
* converting global screen-space coordinates to local isometric grid coords
* as local X increases, global X and Y increase.
* as local Y increases, global Y increases but X decreases. This is how we get the slanted look


* @author Ellaira Torio | 18021275
*/

class World {
    
    Tile[][] tiles;
    int rows = 50;
    int cols = 50;
    
    
    public World() {
        tiles = new Tile[rows][cols];
    } 
    
    private boolean isEdgeTile(int x, int y) {
        int xMin = max(0, x - 1);
        int xMax = min(rows - 1, x + 1);
        int yMin = max(0, y - 1);
        int yMax = min(rows - 1, y + 1);
        
        if (x == xMin || x == xMax || y == yMin || y == yMax) {
            return true;
        } 
        return false;
    }
    
    
    public void initializeTiles() {
        for (int x = 0; x < rows; x++) {
            for (int y = 0; y < cols; y++) {
                Tile t = new Tile(isEdgeTile(x,y), x,y);
                tiles[x][y] = t;
            }
        }
    }
    
    public void drawTiles() {
        for (Tile[] i : tiles) {
            for (Tile t : i) {
                t.drawTile();
            }
        }
    }
    
    public PVector cartesianToIso(PVector p) {
        // Cartesian to isometric:
        float isoX = p.x - p.y;
        float isoY = (p.x + p.y) / 2;
        return new PVector(isoX,isoY);
    }
    // public PVector IsoToCartesian(PVector p) {  
    //     // TODO: convert to java
    //     // var tempPt : Point = new Point(0, 0);
    //     // tempPt.x = (2 * pt.y + pt.x) / 2;
    //     // tempPt.y = (2 * pt.y - pt.x) / 2;
    //     // return(tempPt);
// }
    
}


  public void settings() { size(1920, 1080, P2D); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "FinalProject" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
